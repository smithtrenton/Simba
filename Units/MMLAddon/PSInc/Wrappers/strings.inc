function ps_Capitalize(str : string) : string;extdecl;begin
  result := Capitalize(str);
end;

function ps_CompressString(const Str : string) : string; extdecl;
begin
  result := CompressString(str);
end;

function ps_DecompressString(const Compressed : string) : string; extdecl;
begin
  result := DecompressString(Compressed);
end;

function ps_Base64Encode(const str : string) : string; extdecl;
begin
  result := Base64Encode(str);
end;

function ps_Base64Decode(const str : string) : string; extdecl;
begin
  result := Base64Decode(str);
end;

function ps_ExtractFromStr( Str : string; Extract : StrExtr) : string; extdecl;
begin
  result := extractfromstr(str,extract);
end;

function ps_BoolToStr(bool : boolean) : string; extdecl;
begin;
  result := BoolToStr(bool,true);
end;

function ps_Replace(Text, FindStr, ReplaceStr: string; Flags: TReplaceFlags): string; extdecl;
begin;
  result := StringReplace(Text,FindStr,ReplaceStr,Flags);
end;

function ps_IntToStr(int : integer) : string; extdecl;
begin
  result := inttostr(int);
end;

function ps_FloatToStr(flt : extended) : string; extdecl;
begin
  result := floattostr(flt);
end;

function ps_StrToInt(value: String): Integer; extdecl;
begin
  result := sysutils.StrToInt(value);
end;

function ps_StrToIntDef(value: String; default: Integer): Integer; extdecl;
begin
  result := StrToIntDef(value,default);
end;

function ps_StrToFloat(value: String): Extended; extdecl;
begin
  result := StrToFloat(value);
end;

function ps_StrToFloatDef(value: String; default: Extended): Extended; extdecl;
begin
  result := StrToFloatDef(value,default);
end;

function ps_StrToBool(value: String): Boolean;extdecl;
begin
  result := StrToBool(value);
end;

function ps_StrToBoolDef(value: String; default: Boolean): Boolean; extdecl;
begin
  result := StrToBoolDef(value,default);
end;

function ps_Between(s1, s2, str: string): string; extdecl;
var
  I,J : integer;
begin;
  Result := '';
  I := pos(s1,str);
  if I > 0 then
  begin;
    i := i + length(s1);
    j := posex(s2,str,i);
    if j > 0 then
      Result := copy(str,i,j-i);
  end;
end;

function ps_Implode(Glue : string; Pieces: TStringArray): string;extdecl;
begin
  result := implode(glue,pieces);
end;

function ps_Explode(del, str: string): TStringArray;extdecl;
begin
  result := Explode(del,str);
end;
procedure ps_ExplodeWrap(del, str: string; var res : TStringArray);extdecl;
begin
  res := Explode(del,str);
end;

function ps_Padl(s: String; i: longInt): String;extdecl;
begin
  result := StringOfChar(Char(' '), i - length(s)) + s;
end;

function ps_Padz(s: String; i: longInt): String;extdecl;
begin
  result := StringOfChar(Char('0'), i - length(s)) + s;
end;

function ps_Padr(s: String; i: longInt): String;extdecl;
begin
  result := s + StringOfChar(Char(' '), i - Length(s));
end;

function ps_ExecRegExpr( const RegExpr, InputStr : String) : boolean;extdecl;
begin
  result := execregexpr(RegExpr,InputStr);
end;

procedure ps_SplitRegExpr( const RegExpr, InputStr : String; Pieces : TStrings);extdecl;
begin
  SplitRegExpr(RegExpr,InputStr,Pieces);
end;

function ps_ReplaceRegExpr( const RegExpr, InputStr, ReplaceStr : String; UseSubstitution : boolean) : String;extdecl;
begin
  result := ReplaceRegExpr(RegExpr,InputStr,ReplaceStr,UseSubstitution);
end;

function ps_posex(needle, haystack: String; offset: integer): integer; extdecl;
begin
  result := posex(needle, haystack, offset);
end;

function ps_LevDist(src, target: String): Integer; extdecl;
begin
  Result:= LevDistance(src, target);
end;

function ps_NormLevDist(src, target: String): Extended; extdecl;
begin
  Result := NormLevDistance(src, target);
end;

function ps_StringMatch(checkCompare, goalCompare: string): extended; extdecl;
begin
  result := StringMatch(checkCompare, goalCompare);
end;

function ps_MultiBetween(str, s1, s2: string): TStringArray; extdecl;
begin
  result := MultiBetween(str, s1, s2);
end;

function ps_IsArrInStr(strArr: TStringArray; s: string): boolean; extdecl;
begin
  result := isArrInStr(strArr, s);
end;

function ps_PosMulti(const SubStr:String; text: string): TIntegerArray; extdecl;
begin
  result := PosMulti(SubStr, Text);
end;

function ps_IsStrInArr(const s: string; const UsePos: Boolean; const arr: TStringArray): boolean; extdecl;
begin
  result := IsStrInArr(s, UsePos, arr);
end;
